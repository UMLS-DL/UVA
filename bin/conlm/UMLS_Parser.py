import os
import pickle
import random
import numpy as np
from absl import app, flags

FLAGS = flags.FLAGS

flags.DEFINE_string("AUI_SCUI", "AUI_SCUI_direct_MRCONSO_MASTER_META_DL.RRF",
                    "Specify the path for the AUI_SCUI file")
flags.DEFINE_string("AUI_PAUI", "AUI_PAUI_direct_MRHIER.RRF",
                    "Specify the path for the AUI_PAUI file")
flags.DEFINE_string("SCUI_ParentSCUI", "SCUI_ParentSCUI.RRF",
                    "Specify the path for the SCUI_ParentSCUI file")

flags.DEFINE_string("CUI_SCUI", "CUI_SCUI_direct_MRCONSO.RRF",
                    "Specify the path for the CUI_SCUI file")
flags.DEFINE_string("CUI_STY", "CUI_STY_direct_MRSTY.RRF",
                    "Specify the path for the CUI_STY file")
flags.DEFINE_string("SG_STY", "SemGroups.txt",
                    "Specify the path for the SemGroups file")
flags.DEFINE_string("SCUI_SG", "SCUI_SG.RRF",
                    "Specify the path for the SCUI_SG file")

flags.DEFINE_string("entity2id", "entity2id.txt",
                    "Specify the path for the entity2id file")
flags.DEFINE_string("relation2id", "relation2id.txt",
                    "Specify the path for the relation2id file")

flags.DEFINE_string("entity2id_dump", "entity2id_dump.p",
                    "Specify the path for the entity2id_dump pickle file by PyKeen")
flags.DEFINE_string("relation2id_dump", "relation2id_dump.p",
                    "Specify the path for the relation2id_dump pickle file by PyKeen")

# ConSS
flags.DEFINE_string("AUI_SCUI_Triples_Train", "AUI_SCUI_Triples_Train.txt",
                    "Specify the path for the AUI_SCUI_Triples_Train file")

# ConHR
flags.DEFINE_string("SCUI_ParentSCUI_Triples_Train", "SCUI_ParentSCUI_Triples_Train.txt",
                    "Specify the path for the SCUI_ParentSCUI_Triples_Train file")
# ConSG
flags.DEFINE_string("SCUI_SG_Triples_Train", "SCUI_SG_Triples_Train.txt",
                    "Specify the path for the SCUI_SG_Triples_Train file")

# ConAll
flags.DEFINE_string("All_Triples_Train", "All_Triples_Train.txt",
                    "Specify the path for the All_Triples_Train file")

flags.DEFINE_string("Task", "gen_dataset", "gen_dataset or gen_aui2convec")
flags.DEFINE_string(
    "KGE_Home",
    "..",
    "Path to the home directory of KGE")
flags.DEFINE_string(
    "Embeddings",
    "6-Outputs/embeddings",
    "Path to the embedding folder")
flags.DEFINE_string("Model", "TransE", "TransE, HolE, ")
flags.DEFINE_string(
    "TrainingData",
    "2-BYOD_UMLS",
    "Path to the training data")
flags.DEFINE_string("Raw", "1-Raw", "Path to intermediate dir")
flags.DEFINE_string("AUI2ID", "AUI2ID.PICKLE", "AUI2ID pickle file")
flags.DEFINE_string("Variant", "All_Triples", "All_Triples")
flags.DEFINE_string("Optimizer", "SGD", "SGD, Adam")
flags.DEFINE_string(
    "AUI2CONVEC",
    "aui2convec.pickle",
    "The pickle file for the dictionary AUI:Context vector")

flags.DEFINE_string(
    "meta_dl_dp",
    "../UMLS_VERSIONS/2020AA-ACTIVE/META_DL",
    "Path to META_DL dir")
flags.DEFINE_integer(
    "context_dim",
    50,
    "dimension for the context vector of each context type")
flags.DEFINE_string(
    "num_epochs",
    "100",
    "number of epochs used to train the KGE")


# Generate the AUI vector
def aui2convec_generator():
    print("\nRunning aui2convec_generator...")

    print("Generating aui2scui_dict...")
    # Read the AUI_SCUI_direct_MRCONSO_MASTER_META_DL.RRF
    aui2scui_dict = {}
    aui2scui_f = open("{}/{}".format(FLAGS.KGE_Home, FLAGS.AUI_SCUI), "r")

    lines = aui2scui_f.readlines()
    for line in lines[1:]:
        line = line.strip("\n").split("|")
        aui = line[0]
        scui = line[1]
        aui2scui_dict[aui] = scui

    print("Generating scui2sg_dict...")
    # Read the SCUI_SG.RRF
    scui2sg_dict = {}
    scui2sg_f = open("{}/{}".format(FLAGS.KGE_Home, FLAGS.SCUI_SG), "r")

    lines = scui2sg_f.readlines()
    for line in lines[1:]:
        line = line.strip("\n").split("|")
        scui = line[0]
        sg = line[1]
        scui2sg_dict[scui] = sg

    print("Generating entity2eid_dict...")
    # Read the entity2id_dump.p (Generated by PyKeen)
    entity2eid_f = os.path.join(FLAGS.KGE_Home,
                                FLAGS.Embeddings,
                                FLAGS.Model + "_" +
                                FLAGS.Optimizer + "_" +
                                FLAGS.num_epochs,
                                FLAGS.Variant,
                                FLAGS.entity2id_dump)
    entity2eid_dict = pickle.load(open(entity2eid_f, "rb"))

    print("Generating ent_emb...")
    # Read the ent_embedding
    ent_emb = {}
    ent_emb_f = os.path.join(FLAGS.KGE_Home,
                             FLAGS.Embeddings,
                             FLAGS.Model + "_" +
                             FLAGS.Optimizer + "_" +
                             FLAGS.num_epochs,
                             FLAGS.Variant,
                             FLAGS.Variant +
                             ".p")
    d = pickle.load(open(ent_emb_f, "rb"))

    i = 0
    for row in d["ent_embeddings"]:
        ent_emb[i] = row
        i += 1

    print("Reading AUI2ID.PICKLE...")
    # Read the AUI2ID.PICKLE for all auis
    aui2id = pickle.load(
        open(
            os.path.join(
                FLAGS.meta_dl_dp,
                FLAGS.AUI2ID),
            "rb"))

    print("Generating aui2convec dict...")
    # Generate the AUI2VEC dict
    aui2convec = {}
    zeros_vec = np.zeros(FLAGS.context_dim, dtype=float)
    
    for aui, aui_id in aui2id.items():
        aui_allcon_emb = []

        ########### ConAll ###########
        if (FLAGS.Variant == "All_Triples"):
            # Get trained AUI KGE embedding

            if (aui in aui2scui_dict):
                # Get AUI embedding
                if (aui in entity2eid_dict):
                    aui_allcon_emb = ent_emb[entity2eid_dict[aui]]
                else:
                    aui_allcon_emb = zeros_vec

                # Get SCUI embedding
                scui = aui2scui_dict[aui]
                if (scui in entity2eid_dict):
                    aui_allcon_emb = np.concatenate(
                        [aui_allcon_emb, ent_emb[entity2eid_dict[scui]]])
                else:
                    aui_allcon_emb = np.concatenate(
                        [aui_allcon_emb, zeros_vec])

                # Get SG embedding
                if (scui in scui2sg_dict):
                    sgs = scui2sg_dict[scui].split(",")
                    sgs_emb = []
                    for sg in sgs:
                        if (sg in entity2eid_dict):
                            sgs_emb.append(ent_emb[entity2eid_dict[sg]])
                        else:
                            sgs_emb.append(zeros_vec)
                    sg_emb_avg = np.average(sgs_emb, axis=0)
                    aui_allcon_emb = np.concatenate(
                        [aui_allcon_emb, sg_emb_avg])
                else:
                    aui_allcon_emb = np.concatenate(
                        [aui_allcon_emb, zeros_vec])
            else:
                aui_allcon_emb = np.zeros(3 * FLAGS.context_dim, dtype=float)

        ########### ConSS ###########
        elif (FLAGS.Variant == "AUI_SCUI_Triples"):
            if (aui in aui2scui_dict):
                # Get AUI embedding
                if (aui in entity2eid_dict):
                    aui_allcon_emb = ent_emb[entity2eid_dict[aui]]
                else:
                    aui_allcon_emb = zeros_vec

                # Get SCUI embedding
                scui = aui2scui_dict[aui]
                if (scui in entity2eid_dict):
                    aui_allcon_emb = np.concatenate(
                        [aui_allcon_emb, ent_emb[entity2eid_dict[scui]]])
                else:
                    aui_allcon_emb = np.concatenate(
                        [aui_allcon_emb, zeros_vec])
            else:
                aui_allcon_emb = np.zeros(2 * FLAGS.context_dim, dtype=float)

        ########### ConSG ###########
        elif (FLAGS.Variant == "SCUI_SG_Triples"):
            if (aui in aui2scui_dict):
                # Get SCUI embedding
                scui = aui2scui_dict[aui]
                if (scui in entity2eid_dict):
                    aui_allcon_emb = ent_emb[entity2eid_dict[scui]]
                else:
                    aui_allcon_emb = zeros_vec
                
                # Get SG embedding
                if (scui in scui2sg_dict):
                    sgs = scui2sg_dict[scui].split(",")
                    sgs_emb = []
                    for sg in sgs:
                        if (sg in entity2eid_dict):
                            sgs_emb.append(ent_emb[entity2eid_dict[sg]])
                        else:
                            sgs_emb.append(zeros_vec)
                    sg_emb_avg = np.average(sgs_emb, axis=0)
                    aui_allcon_emb = np.concatenate(
                        [aui_allcon_emb, sg_emb_avg])
                else:
                    aui_allcon_emb = np.concatenate(
                        [aui_allcon_emb, zeros_vec])
            else:
                aui_allcon_emb = np.zeros(2 * FLAGS.context_dim, dtype=float)

        ########### ConHR ###########
        elif (FLAGS.Variant == "SCUI_ParentSCUI_Triples"):
            if (aui in aui2scui_dict):
                # Get SCUI embedding
                scui = aui2scui_dict[aui]
                if (scui in entity2eid_dict):
                    aui_allcon_emb = ent_emb[entity2eid_dict[scui]]
                else:
                    aui_allcon_emb = zeros_vec
            else:
                aui_allcon_emb = np.zeros(1 * FLAGS.context_dim, dtype=float)

        aui2convec[aui_id] = aui_allcon_emb

    print("Generating aui2convec file...")
    # Generate the aui2convec file
    aui2convec_dump_PATH = os.path.join(FLAGS.KGE_Home,
                                        FLAGS.Embeddings,
                                        FLAGS.Model + "_" +
                                        FLAGS.Optimizer + "_" +
                                        FLAGS.num_epochs,
                                        FLAGS.Variant)
    pickle.dump(
        aui2convec,
        open("{}/{}_{}".format(aui2convec_dump_PATH, FLAGS.Variant, FLAGS.AUI2CONVEC), "wb"), protocol=4)
    
    print("Done! aui2convec file successfully generated into {}".format(aui2convec_dump_PATH))

    return


# Read the entity2id and relation2id to create dictionaries
# Then read the AUI_SCUI_direct_MRCONSO_MASTER_META_DL.RRF
# SCUI_ParentSCUI.RRF
# and SCUI_SG.RRF
# Generate triples for each entry
def triple_generator():
    print("\nRunning triple_generator...")

    master_triples_train=[]

    ########### ConSS ###########
    # Generate AUI_SCUI triples
    print("Generating AUI_SCUI triples...")
    triples=[]
    with open(FLAGS.AUI_SCUI, "r") as f:
        lines=f.readlines()

        for line in lines[1:]:
            line=line.split("|")

            AUI, SCUI=line[0].strip(), line[1].strip()

            # Each AUI is optionally associated with one identifier provided by its source
            # If AUI is empty or AUI does not have SCUI
            # continue
            if AUI == "" or SCUI == "":
                continue

            try:
                triples.append("{}\t{}\t{}".format(AUI, "AUI_SCUI", SCUI))
            except KeyError:
                print("KeyError: {} or {}".format(AUI, SCUI))
                continue

    # Shuffle triples
    random.shuffle(triples)
    num_triples=len(triples)
    aui_scui_triples_train = triples

    num_aui_scui_triples_train = len(aui_scui_triples_train)

    # Write AUI_SCUI triples into file
    with open(FLAGS.AUI_SCUI_Triples_Train, "w") as w:
        for triple in aui_scui_triples_train:
            w.write("{}\n".format(triple))

    # Append to master_triples
    master_triples_train += aui_scui_triples_train

    print("Done! {} train triples successfully generated!".format(num_aui_scui_triples_train))

    ########### ConHR ###########
    # Generate SCUI_ParentSCUI triples
    print("Generating SCUI_ParentSCUI triples...")
    triples=[]
    with open(FLAGS.SCUI_ParentSCUI, "r") as f:
        lines=f.readlines()

        for line in lines[1:]:
            line=line.split("|")

            SCUI, ParentSCUI=line[0].strip(), line[1].split(",")

            # If SCUI is empty or SCUI does not have ParentSCUI
            # continue
            if SCUI == "" or len(ParentSCUI) == 0:
                continue

            for parentSCUI in ParentSCUI:
                parentSCUI=parentSCUI.strip()
                try:
                    triples.append(
                        "{}\t{}\t{}".format(
                            SCUI,
                            "SCUI_ParentSCUI",
                            parentSCUI))
                except KeyError:
                    print("KeyError: {} or {}".format(SCUI, parentSCUI))
                    continue

    # Shuffle triples
    random.shuffle(triples)
    num_triples=len(triples)
    scui_parentscui_triples_train = triples

    num_scui_parentscui_triples_train = len(scui_parentscui_triples_train)

    # Write SCUI_ParentSCUI triples into file
    with open(FLAGS.SCUI_ParentSCUI_Triples_Train, "w") as w:
        for triple in scui_parentscui_triples_train:
            w.write("{}\n".format(triple))

    # Append to master_triples
    master_triples_train += scui_parentscui_triples_train

    print("Done! {} train triples successfully generated!".format(num_scui_parentscui_triples_train))

    ########### ConSG ###########
    # Generate SCUI_SG triples
    print("Generating SCUI_SG triples...")
    triples=[]
    with open(FLAGS.SCUI_SG, "r") as f:
        lines=f.readlines()

        for line in lines[1:]:
            line=line.split("|")

            SCUI, SG=line[0].strip(), line[1].split(",")

            # Some source vocabulary may not have source semantic group
            # If SCUI is empty or SCUI does not have SG
            # continue
            if SCUI == "" or len(SG) == 0:
                continue

            for sg in SG:
                sg=sg.strip()
                try:
                    triples.append(
                        "{}\t{}\t{}".format(
                            SCUI, "SCUI_SG", sg))
                except KeyError:
                    print("KeyError: {} or {}".format(SCUI, sg))
                    continue

    # Shuffle triples
    random.shuffle(triples)
    num_triples=len(triples)
    scui_sg_triples_train = triples

    num_scui_sg_triples_train = len(scui_sg_triples_train)

    # Write SCUI_SG triples into file
    with open(FLAGS.SCUI_SG_Triples_Train, "w") as w:
        for triple in scui_sg_triples_train:
            w.write("{}\n".format(triple))

    # Append to master_triples
    master_triples_train += scui_sg_triples_train

    print("Done! {} train triples successfully generated!".format(num_scui_sg_triples_train))

    ########### ConAll ###########
    # Write ALL triples into file
    print("Writing ALL triples...")

    random.shuffle(master_triples_train)

    num_master_triples_train=len(master_triples_train)

    with open(FLAGS.All_Triples_Train, "w") as w:
        for triple in master_triples_train:
            w.write("{}\n".format(triple))

    print("Done! {} train triples successfully generated!".format(num_master_triples_train))


# Generate relation2id
def relation2id_generator():
    relation2id_dict={
        "AUI_SCUI": 0,
        "SCUI_SG": 1,
        "SCUI_ParentSCUI": 2
    }
    num_relation2id = len(relation2id_dict)
    with open(FLAGS.relation2id, "w") as w:
        # w.write("{}\n".format(num_relation2id))
        for relation, _id in relation2id_dict.items():
            w.write("{}\t{}\n".format(relation, _id))

    print(
        "Done! {} relation(s) successfully generated into {}!".format(
            num_relation2id,
            FLAGS.relation2id))


# Read the AUI_SCUI_direct_MRCONSO_MASTER_META_DL.RRF
# SCUI_ParentSCUI.RRF
# and SCUI_SG.RRF
# Generate unique id for each unique entity
def entity2id_generator():
    AUI_dict = {}
    SCUI_dict = {}
    SG_dict = {}

    print("\nRunning entity2id_generator...")

    with open(FLAGS.AUI_SCUI, "r") as f:
        lines = f.readlines()

        for line in lines[1:]:
            line = line.split("|")
            AUI, SCUI = line[0].strip(), line[1].strip()

            if AUI not in AUI_dict:
                AUI_dict[AUI] = 1
            else:
                AUI_dict[AUI] += 1

            if SCUI not in SCUI_dict:
                SCUI_dict[SCUI] = 1
            else:
                SCUI_dict[SCUI] += 1

    with open(FLAGS.SCUI_ParentSCUI, "r") as f:
        lines = f.readlines()

        for line in lines[1:]:
            line = line.split("|")
            SCUI, ParentSCUI = line[0].strip(), line[1].split(",")

            if SCUI not in SCUI_dict:
                SCUI_dict[SCUI] = 1
            else:
                SCUI_dict[SCUI] += 1

            for parentSCUI in ParentSCUI:
                parentSCUI = parentSCUI.strip()
                if parentSCUI not in SCUI_dict:
                    SCUI_dict[parentSCUI] = 1
                else:
                    SCUI_dict[parentSCUI] += 1

    with open(FLAGS.SCUI_SG, "r") as f:
        lines = f.readlines()

        for line in lines[1:]:
            line = line.split("|")
            SCUI, SG = line[0].strip(), line[1].split(",")

            if SCUI not in SCUI_dict:
                SCUI_dict[SCUI] = 1
            else:
                SCUI_dict[SCUI] += 1

            for sg in SG:
                sg = sg.strip()
                if sg not in SG_dict:
                    SG_dict[sg] = 1
                else:
                    SG_dict[sg] += 1

    i = 0

    num_entities = len(AUI_dict) + len(SCUI_dict) + len(SG_dict)

    with open(FLAGS.entity2id, "w") as f:
        # f.write("{}\n".format(num_entities))

        for key, value in AUI_dict.items():
            f.write("{}\t{}\n".format(key, i))
            i += 1

        for key, value in SCUI_dict.items():
            f.write("{}\t{}\n".format(key, i))
            i += 1

        for key, value in SG_dict.items():
            f.write("{}\t{}\n".format(key, i))
            i += 1

    print(
        "Done! {} entities successfully generated into {}!".format(
            num_entities,
            FLAGS.entity2id))


# Generate SCUI|SG output file
# First read the SemGroups.txt file to create STY_SG dictionary mapping
# Read the CUI_STY file to create CUI_SG dictionary mapping with STY as the proxy between CUI_STY and STY_SG
# Read the CUI_SCUI file to create SCUI_SG dictionary mapping with CUI as
# the proxy between CUI_SCUI and CUI_SG
def SCUI_SG_generator():
    SCUI_SG_dict = {}
    CUI_SG_dict = {}
    STY_SG_dict = {}

    print("\nRunning SG_STY_generator...")

    with open(FLAGS.SG_STY, "r") as f:
        lines = f.readlines()

        for line in lines:
            line = line.split("|")
            SG, STY = line[0].strip(), line[3].strip()

            if STY not in STY_SG_dict:
                STY_SG_dict[STY] = SG
            else:
                print("{} already exists!".format(STY))

    with open(FLAGS.CUI_STY, "r") as f:
        lines = f.readlines()

        for line in lines:
            line = line.split("|")
            CUI, STY = line[0].strip(), line[1].strip()
            if CUI not in CUI_SG_dict:
                try:
                    CUI_SG_dict[CUI] = [STY_SG_dict[STY]]
                except KeyError:
                    continue
            else:
                try:
                    if STY_SG_dict[STY] not in CUI_SG_dict[CUI]:
                        CUI_SG_dict[CUI].append(STY_SG_dict[STY])
                except KeyError:
                    continue

    with open(FLAGS.CUI_SCUI, "r") as f:
        lines = f.readlines()

        for line in lines:
            line = line.split("|")
            CUI, SCUI = line[0].strip(), line[1].strip()

            if SCUI not in SCUI_SG_dict:
                try:
                    SCUI_SG_dict[SCUI] = [CUI_SG_dict[CUI]]
                except KeyError:
                    continue
            else:
                try:
                    if CUI_SG_dict[CUI] not in SCUI_SG_dict[SCUI]:
                        SCUI_SG_dict[SCUI].append(CUI_SG_dict[CUI])
                except KeyError:
                    continue

    SCUI_SG_dict.pop("")
    with open(FLAGS.SCUI_SG, "w") as f:
        f.write("SCUI|SG\n")
        for key, value in SCUI_SG_dict.items():
            values = []
            for item in value:
                for element in item:
                    values.append(element)

            f.write("{}|{}\n".format(key, ",".join(values)))

    print("Done! {} successfully generated!".format(FLAGS.SCUI_SG))


# Generate SCUI|ParentSCUI output file
# Reads the corresponding SCUI for an AUI from AUI_SCUI file
# Then read the AUI_PAUI file and look up the
# SCUI of the AUI and the SCUI of the PAUI
def SCUI_ParentSCUI_generator():
    AUI_SCUI_dict = {}
    SCUI_ParentSCUI_dict = {}

    print("\nRunning SCUI_ParentSCUI_generator...")

    with open(FLAGS.AUI_SCUI, "r") as f:
        lines = f.readlines()

        for line in lines:
            line = line.split("|")
            AUI, SCUI = line[0].strip(), line[1].strip()

            if AUI not in AUI_SCUI_dict:
                if AUI is not "" or SCUI is not "":
                    AUI_SCUI_dict[AUI] = SCUI
            else:
                print("Duplicate {} AUI found with SCUI {}".format(AUI, SCUI))

    with open(FLAGS.AUI_PAUI, "r") as f:
        lines = f.readlines()

        for line in lines:
            line = line.split("|")
            AUI, PAUI = line[0].strip(), line[1].strip()

            # If SCUI does not exist, create new entry
            try:
                if AUI is not "" and PAUI is not "" and AUI_SCUI_dict[AUI] not in SCUI_ParentSCUI_dict:
                    try:
                        SCUI_ParentSCUI_dict[AUI_SCUI_dict[AUI]] = [
                            AUI_SCUI_dict[PAUI]]
                    except KeyError:
                        continue
                # if SCUI entry exists
                else:
                    try:
                        # then check whether the ParentSCUI is a duplicate
                        # before appending
                        if AUI_SCUI_dict[PAUI] not in SCUI_ParentSCUI_dict[AUI_SCUI_dict[AUI]]:
                            SCUI_ParentSCUI_dict[AUI_SCUI_dict[AUI]].append(
                                AUI_SCUI_dict[PAUI])
                    except KeyError:
                        continue
            except KeyError:
                continue

    SCUI_ParentSCUI_dict.pop("")
    with open(FLAGS.SCUI_ParentSCUI, "w") as f:
        f.write("SCUI|ParentSCUI\n")
        for key, value in SCUI_ParentSCUI_dict.items():
            f.write("{}|{}\n".format(key, ",".join(value)))

    print("Done! {} successfully generated!".format(FLAGS.SCUI_ParentSCUI))


def main(_):
    if FLAGS.Task == "gen_dataset":
        SCUI_ParentSCUI_generator()
        SCUI_SG_generator()
        entity2id_generator()
        relation2id_generator()
        triple_generator()
    elif FLAGS.Task == "gen_aui2convec":
        aui2convec_generator()


if __name__ == "__main__":
    app.run(main)
